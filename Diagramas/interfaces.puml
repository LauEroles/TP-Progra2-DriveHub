@startuml interfaces

' Una opcion podía ser tener una clase Sistema/Empresa que sea la orquestadora.
' Problema --> tendría muchos métodos sueltos y haría de todo, no es la idea.
' Posible solucion aprobada x el profe --> clase Sistema/Empresa que implemente varias interfaces
' Así los métodos relacionados están agrupados, separamos funcionalidades, y la clase queda más limpia


class SistemaEmpresa implements GestionVehiculos, GestionReserva, GestionMantenimiento, GestionKilometraje {
    - vehiculos = Array<Vehiculo>
    - reservas = Array<Reserva>
}


class Cliente {
    + solicitarReserva(r: Reserva, s: Sistema): void  
}
' Cliente pide al sistema una reserva (previamente instanciada), y este la tendra que validar llamando a validarDisponibilidad();
' si es válida se carga en sistema (agrega a lista), sino tira una excepcion (reserva rechazada)


interface GestionVehiculos {
    + agregarVehiculo(): void  
    ' Agrega un vehiculo a la lista
    + eliminarVehiculo(): void  
    ' Elimina un vehiculo de la lista
    + cambiarEstado(v: Vehiculo, e: Estado): void  
    ' Le cambia el Estado (enum) a un vehiculo (a traves de su setter)
}


interface GestionReserva {
    + validarDisponibilidad(r: Reserva): boolean  
    ' Valida la disponibilidad del vehículo para las fechas solicitadas

    + agregarReserva(r: Reserva): void  
    ' Agrega una reserva a la lista
    + eliminarReserva(r: Reserva): void  
    ' Elimina una reserva de la lista
       
    + calcularTotal(r: Reserva): number  
    ' Podriamos calcular el total usando calcularCostoVariable() del vehiculo y sumar la tarifa base 
    ' (y costo fijo) aca, para que el vehiculo solo calcule su costo variable y no el total de la reserva
}


interface GestionKilometraje {
    + calcularKmsRecorridos()
    ' Esto lo sacaría tal vez y haría que Reserva tenga un método kmsRecorridos() que los calcule
    ' ya que ella misma posee kmInicial y kmFinal (seteado despues), y que calcularTotal() en GestionReserva llame a ese método
}


interface GestionMantenimiento {
    + registrarMantenimiento(v: Vehiculo, m: Mantenimiento): void  ' Le agrega un mantenimiento a un vehiculo
    ' Vehiculo podría tener un array de mantenimentos (tipo Mantenimiento) para tener registrados todos los que se le hacen
    ' Objeto mantenimento tiene fecha y costo (simil estructura de datos)
}


@enduml